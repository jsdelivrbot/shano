diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheDrupal.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheDrupal.php
new file mode 100644
index 00000000..9d26f0de
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheDrupal.php
@@ -0,0 +1,88 @@
+<?php
+
+namespace mssql\Component;
+
+/**
+ * Drupal cache can use different back ends (database, RAM: redis, memcache etc).
+ * Use this for very frequently used cache items.
+ */
+class CacheDrupal implements CacheInterface {
+
+  private $prefix = NULL;
+
+  /**
+   * This cache stores everything in-memory during the
+   * lifetime of this request.
+   *
+   * @var array
+   */
+  private $data = array();
+
+  /**
+   * Serializer to use.
+   *
+   * @var SerializerInterface
+   */
+  private $serializer = NULL;
+
+  public function __construct($prefix) {
+    $this->prefix = $prefix;
+
+    // Try to use a serializer...
+    if (function_exists('igbinary_serialize')) {
+      $this->serializer = new SerializerIgbinary();
+    }
+    else {
+      $this->serializer = new SerializerPhp();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Set($cid, $data) {
+    $cache = new \stdClass();
+    $cache->data = $data;
+    $cache->serialized = FALSE;
+    $cache->timestamp = time();
+    $this->data[$cid] = clone $cache;
+
+    \Drupal::cache('sqlsrv')->set($this->prefix . ':' . $cid, $cache);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Get($cid) {
+    if (isset($this->data[$cid])) {
+      return $this->data[$cid];
+    }
+
+    $result = \Drupal::cache('sqlsrv')->get($this->prefix . ':' . $cid);
+
+    $success = !empty($result->valid);
+
+    if (!$success) {
+      return FALSE;
+    }
+
+    $result = $result->data;
+
+    if ($result->serialized) {
+      $result->data = $this->serializer->unserialize($result->data);
+    }
+
+    $this->data[$cid] = $result;
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Clear($cid) {
+    \Drupal::cache('sqlsrv')->delete($this->prefix . ':' . $cid);
+
+    unset($this->data[$cid]);
+  }
+}
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryDefault.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryDefault.php
new file mode 100644
index 00000000..17b689a1
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryDefault.php
@@ -0,0 +1,45 @@
+<?php
+
+namespace mssql\Component;
+
+class CacheFactoryDefault implements CacheFactoryInterface {
+  /**
+   * Unique prefix for this site/database
+   *
+   * @param string $prefix
+   *   Unique prefix for this site/database
+   */
+  public function __construct($prefix) {
+    $this->prefix = $prefix;
+  }
+  /**
+   * Unique prefix for this database
+   * 
+   * @var string
+   */
+  protected $prefix;
+  /**
+   * List of already loaded cache binaries.
+   *
+   * @var CacheInterface[]
+   */
+  protected $binaries = array();
+  /**
+   * {@inhertidoc}
+   */
+  public function get($bin) {
+    $name = $this->prefix . ':' . $bin;
+
+    if (!isset($this->binaries[$name])) {
+      // This cache is available only on Windows, so if we using this library on Linux
+      // use Drupal cache subsystem (Redis, Memcache etc).
+      if (function_exists('wincache_ucache_set')) {
+        $this->binaries[$name] = new CacheWincache($name);
+      } else {
+        $this->binaries[$name] = new CacheDrupal($name);
+      }
+    }
+
+    return $this->binaries[$name];
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryInterface.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryInterface.php
new file mode 100644
index 00000000..6a45aa7c
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheFactoryInterface.php
@@ -0,0 +1,15 @@
+<?php
+
+namespace mssql\Component;
+
+interface CacheFactoryInterface {
+
+  /**
+   * Get a cache backend for a specific binary.
+   *
+   * @param  string $bin
+   *
+   * @return CacheInterface
+   */
+  function get($bin);
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheInterface.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheInterface.php
new file mode 100644
index 00000000..8162d23c
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheInterface.php
@@ -0,0 +1,29 @@
+<?php
+
+namespace mssql\Component;
+
+interface CacheInterface {
+
+  /**
+   * Set a cache item.
+   *
+   * @param string $cid
+   * @param mixed $data
+   */
+  function Set($cid, $data);
+
+  /**
+   * Get a cache item.
+   *
+   * @param mixed $cid
+   */
+  function Get($cid);
+
+  /**
+   * Clear a cache item.
+   *
+   * @param string $cid
+   */
+  function Clear($cid);
+
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheWincache.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheWincache.php
new file mode 100644
index 00000000..80c2ddf3
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/CacheWincache.php
@@ -0,0 +1,78 @@
+<?php
+
+namespace mssql\Component;
+
+/**
+ * Wincache implementation for the in-memory fast
+ * cache. Use this for very frequently used cache items.
+ */
+class CacheWincache implements CacheInterface {
+
+  private $prefix = NULL;
+
+  /**
+   * This cache stores everything in-memory during the
+   * lifetime of this request.
+   *
+   * @var array
+   */
+  private $data = array();
+
+  /**
+   * Serializer to use.
+   *
+   * @var SerializerInterface
+   */
+  private $serializer = NULL;
+
+  public function __construct($prefix) {
+    $this->prefix = $prefix;
+
+    // Try to use a serializer...
+    if (function_exists('igbinary_serialize')) {
+      $this->serializer = new SerializerIgbinary();
+    }
+    else {
+      $this->serializer = new SerializerPhp();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Set($cid, $data) {
+    $cache = new \stdClass();
+    $cache->data = $data;
+    $cache->serialized = FALSE;
+    $cache->timestamp = time();
+    $this->data[$cid] = clone $cache;
+    wincache_ucache_set($this->prefix . ':' . $cid, $cache);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Get($cid) {
+    if (isset($this->data[$cid])) {
+      return $this->data[$cid];
+    }
+    $success = FALSE;
+    $result = wincache_ucache_get($this->prefix . ':' . $cid, $success);
+    if (!$success) {
+      return FALSE;
+    }
+    if ($result->serialized) {
+      $result->data = $this->serializer->unserialize($result->data);
+    }
+    $this->data[$cid] = $result;
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  function Clear($cid) {
+    wincache_ucache_delete($this->prefix . ':' . $cid);
+    unset($this->data[$cid]);
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/Enum.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/Enum.php
new file mode 100644
index 00000000..aeb4a572
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/Enum.php
@@ -0,0 +1,150 @@
+<?php
+
+namespace mssql\Component;
+
+use UnexpectedValueException;
+use ReflectionClass;
+use BadMethodCallException;
+
+/**
+ * Enum class.
+ *
+ */
+abstract class Enum {
+
+  /**
+   * Enum value
+   *
+   * @var mixed
+   */
+  protected $value;
+
+  /**
+   * Store existing constants in a static cache per object.
+   *
+   * @var array
+   */
+  private static $cache = array();
+
+  /**
+   * Creates a new value of some type
+   *
+   * @param mixed $value
+   *
+   * @throws UnexpectedValueException
+   */
+  public function __construct($value) {
+    if (!$this->isValid($value)) {
+      throw new UnexpectedValueException("Value '$value' is not part of the enum " . get_called_class());
+    }
+    $this->value = $value;
+  }
+
+  /**
+   * @return mixed
+   */
+  public function getValue() {
+    return $this->value;
+  }
+
+  /**
+   * Returns the enum key (i.e. the constant name).
+   *
+   * @return mixed
+   */
+  public function getKey() {
+    return self::search($this->value);
+  }
+
+  /**
+   * @return string
+   */
+  public function __toString() {
+    return (string) $this->value;
+  }
+
+  /**
+   * Returns the names (keys) of all constants in the Enum class
+   *
+   * @return array
+   */
+  public static function keys() {
+    return array_keys(self::toArray());
+  }
+
+  /**
+   * Returns instances of the Enum class of all Enum constants
+   *
+   * @return array Constant name in key, Enum instance in value
+   */
+  public static function values() {
+    $values = array();
+    foreach (self::toArray() as $key => $value) {
+      $values[$key] = new static($value);
+    }
+    return $values;
+  }
+
+  /**
+   * Returns all possible values as an array
+   *
+   * @return array Constant name in key, constant value in value
+   */
+  public static function toArray() {
+    $class = get_called_class();
+    if (!array_key_exists($class, self::$cache)) {
+      $reflection = new ReflectionClass($class);
+      self::$cache[$class] = $reflection->getConstants();
+    }
+    return self::$cache[$class];
+  }
+  /**
+   *
+   * Check if is valid enum value
+   *
+   * @param $value
+   * @return bool
+   */
+  public static function isValid($value) {
+    return in_array($value, self::toArray(), true);
+  }
+
+  /**
+   * Check if is valid enum key
+   *
+   * @param $key
+   *
+   * @return bool
+   */
+  public static function isValidKey($key) {
+    $array = self::toArray();
+    return isset($array[$key]);
+  }
+
+  /**
+   * Return key for value
+   *
+   * @param $value
+   *
+   * @return mixed
+   */
+  public static function search($value) {
+    return array_search($value, self::toArray(), true);
+  }
+
+  /**
+   * Returns a value when called statically like so: MyEnum::SOME_VALUE() given SOME_VALUE is a class constant
+   *
+   * @param string $name
+   * @param array  $arguments
+   *
+   * @return static
+   * @throws BadMethodCallException
+   */
+  public static function __callStatic($name, $arguments) {
+    if (defined("static::$name")) {
+      return new static(constant("static::$name"));
+    }
+    throw new BadMethodCallException("No static method or enum constant '$name' in class " . get_called_class());
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerIgbinary.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerIgbinary.php
new file mode 100644
index 00000000..3d2f716b
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerIgbinary.php
@@ -0,0 +1,20 @@
+<?php
+
+namespace mssql\Component;
+
+class SerializerIgbinary implements SerializerInterface {
+
+  /**
+   * {@inheritdoc}
+  */
+  public function serialize($value) {
+    return igbinary_serialize($value);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function unserialize($value) {
+    return igbinary_unserialize($value);
+  }
+}
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerInterface.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerInterface.php
new file mode 100644
index 00000000..eb547b51
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerInterface.php
@@ -0,0 +1,24 @@
+<?php
+
+namespace mssql\Component;
+
+interface SerializerInterface {
+
+  /**
+   * Serialize data.
+   * 
+   * @param mixed $data
+   * 
+   * @return string
+   */
+  function serialize($data);
+
+  /**
+   * Unserialize data.
+   * 
+   * @param string $data 
+   * 
+   * @return mixed
+   */
+  function unserialize($data);
+}
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerPhp.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerPhp.php
new file mode 100644
index 00000000..5ef65c03
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SerializerPhp.php
@@ -0,0 +1,20 @@
+<?php
+
+namespace mssql\Component;
+
+class SerializerPhp implements SerializerInterface {
+
+  /**
+   * {@inheritdoc}
+  */
+  public function serialize($value) {
+    return serialize($value);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function unserialize($value) {
+    return unserialize($value);
+  }
+}
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SettingsManager.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SettingsManager.php
new file mode 100644
index 00000000..d467a694
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Component/SettingsManager.php
@@ -0,0 +1,50 @@
+<?php
+
+namespace mssql\Component;
+
+class SettingsManager {
+  /**
+   * Stored settings.
+   *
+   * @var mixed
+   */
+  private $settings = array();
+
+  /**
+   * Store or retrieve a setting.
+   *
+   * @param string $method
+   * @param array $args
+   * @return mixed
+   */
+  protected function &CallMethod($method, array $options = array(), array $args = array(), $default = NULL) {
+    if (empty($args)) {
+      if (!isset($this->settings[$method])) {
+        $this->settings[$method] = $default;
+      }
+
+      return  $this->settings[$method];
+    }
+
+    $value = reset($args);
+
+    if (!empty($options)) {
+      if (!in_array($value, $options)) {
+        throw new \Exception("Invalid value");
+      }
+    }
+
+    $this->settings[$method] = $value;
+
+    return $this->settings[$method];
+  }
+  /**
+   * Retrieve the raw settings.
+   * 
+   * @return array
+   */
+  public function getSettings() {
+    return $this->settings;
+  }
+
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Connection.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Connection.php
new file mode 100644
index 00000000..2f6bd407
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Connection.php
@@ -0,0 +1,321 @@
+<?php
+namespace mssql;
+use PDO;
+use PDOException;
+class Connection extends PDO {
+  /**
+   * Use this when preparing a statement to
+   * retry operations that fail with integrity
+   * constraint violations. Useful when
+   * using MERGE statements - than can fail
+   * on high concurrency scenarios.
+   */
+  const PDO_RETRYONINTEGRITYVIOLATION = 'PDO_RETRYONINTEGRITYVIOLATION';
+  /**
+   * Some environments such as Azure require retry logic
+   * at the statement level. Use this to enable it.
+   */
+  const PDO_RESILIENTRETRY = 'PDO_RESILIENTRETRY';
+  /**
+   * @var Scheme
+   */
+  private $scheme = NULL;
+  /**
+   * @var Component\CacheFactoryInterface
+   */
+  private $cache = NULL;
+  /**
+   * If the transaction is doomed.
+   *
+   * @var bool
+   */
+  private $doomed_transaction = FALSE;
+  /**
+   * The original exception that doomed the transaction.
+   * 
+   * @var \Exception
+   */
+  private $doomed_transaction_exception = NULL;
+  /**
+   * If we are currently inside a transaction.
+   *
+   * @var bool
+   */
+  private $in_transaction = FALSE;
+  public function __construct($dsn, $username = NULL, $password = NULL, array $driver_options = array(), Component\CacheFactoryInterface $cache = NULL) {
+    if (empty($cache)) {
+      $this->cache = new Component\CacheFactoryDefault(md5(implode(':', [$dsn, $username, $password])));
+    }
+    else {
+      $this->cache = $cache;
+    }
+    parent::__construct($dsn, $username, $password, $driver_options);
+    $this->scheme = new Scheme($this);
+  }
+  /**
+   * @return Scheme
+   */
+  public function Scheme() {
+    return $this->scheme;
+  }
+  /**
+   * @return Component\CacheInterface
+   */
+  public function Cache($bin = 'cache') {
+    return $this->cache->get($bin);
+  }
+  /**
+   * If we are in a transaction and the transaction is doomed.
+   */
+  public function InDoomedTransaction() {
+    return $this->doomed_transaction;
+  }
+  /**
+   * {@inheritdoc}
+   */
+  public function prepare($query, $options = []) {
+    // Remove our custom prepare options, otherwise the PDO will
+    // crash.
+    $custom = [self::PDO_RESILIENTRETRY, self::PDO_RETRYONINTEGRITYVIOLATION];
+    $pdo_options = array_diff_key($options, array_flip($custom));
+    /** @var Statement */
+    $statement  = parent::prepare($query, $pdo_options);
+    $statement->SetConnection($this, $options);
+    return $statement;
+  }
+  /**
+   * {@inhertidoc}
+   */
+  public function exec($statement) {
+    try {
+      return parent::exec($statement);
+    }
+    catch (\PDOException $e) {
+      $this->NotifyException($e);
+      throw $e;
+    }
+  }
+  /**
+   * {@inheritdoc}
+   */
+  public function query($statement, $fetch_mode = NULL, $p1 = NULL, $p2 = NULL) {
+    // By overriding this we are just making sure that we are able to INTERCEPT
+    // any exception that might happen during a transaction.
+    try {
+      if (empty($fetch_mode)) {
+        return parent::query($statement);
+      }
+      switch ($fetch_mode) {
+        case PDO::FETCH_COLUMN:
+          return parent::query($statement, $fetch_mode, $p1);
+        case PDO::FETCH_CLASS:
+          return parent::query($statement, $fetch_mode, $p1, $p2);
+        case PDO::FETCH_INTO:
+          return parent::query($statement, $fetch_mode, $p1, $p2);
+        default:
+          throw new \Exception("query() call not supported. Second argument needs to be one of PDO::FETCH_COLUMN | PDO::FETCH_CLASS | PDO::FETCH_INTO. Use query_execute() instead.");
+      }
+    }
+    catch (\PDOException $e) {
+      $this->NotifyException($e);
+      throw $e;
+    }
+  }
+  protected function defaultOptions() {
+    return array(
+      'target' => 'default',
+      'fetch' => \PDO::FETCH_OBJ,
+      'throw_exception' => TRUE,
+      'allow_delimiter_in_query' => FALSE,
+    );
+  }
+  /**
+   * Custom function to easy querying data without needing to prepare.
+   *
+   * @param mixed $query
+   * @param array $args
+   * @param mixed $options
+   * @throws PDOException
+   * @return mixed
+   */
+  public function query_execute($query, array $args = array(), $options = array()) {
+    try {
+      // Make sure we are not preparing statements.
+      $options[PDO::SQLSRV_ATTR_DIRECT_QUERY] = TRUE;
+      /** @var Statement */
+      $stmt = $this->prepare($query, $options);
+      $stmt->execute($args);
+      return $stmt;
+    }
+    catch (\PDOException $e) {
+      $this->NotifyException($e);
+      throw $e;
+    }
+  }
+  /**
+   * {@inheritdoc}
+   */
+  public function rollBack() {
+    $this->in_transaction = FALSE;
+    $this->doomed_transaction = FALSE;
+    return parent::rollBack();
+  }
+  /**
+   * {@inheritdoc}
+   */
+  public function beginTransaction() {
+    parent::beginTransaction();
+    $this->in_transaction = TRUE;
+  }
+  /**
+   * {@inheritdoc}
+   */
+  public function commit() {
+    if ($this->doomed_transaction) {
+      // We are about to throw an Exception, this is the last word of warning...
+      // so it is safe to release the lock from the connection now...
+      $this->doomed_transaction = FALSE;
+      $this->ThrowDoomedTransactionException();
+    }
+    $this->in_transaction = FALSE;
+    return parent::commit();
+  }
+  /**
+   * PDO Exception codes that we know will not doom
+   * the current transaction.
+   *
+   * @var array
+   */
+  protected $allowed_pdo_exception_codes = array('42S02' => TRUE);
+  /**
+   * Only to be used by statements to notify of a PDO exception.
+   *
+   * @param \PDOException $e
+   */
+  public function NotifyException(\PDOException $e) {
+    // Protection against issue of PDO driver.
+    if ($this->in_transaction) {
+      // Some PDO exceptions are "safe" and will not doom the
+      // transaction.
+      if (!isset($this->allowed_pdo_exception_codes[$e->getCode()])) {
+        $this->doomed_transaction = TRUE;
+        $this->doomed_transaction_exception = $e;
+      }
+    }
+  }
+  /**
+   * @see https://github.com/Azure/msphpsql/issues/50
+   *
+   * @throws PDOException
+   */
+  public function ThrowDoomedTransactionException() {
+    throw new DoomedTransactionException("Msg 3930, Level 16, State 1, Line 21\r\nThe current transaction cannot be committed and cannot support operations that write to the log file. Roll back the transaction.", 0, $this->doomed_transaction_exception);
+  }
+  /**
+   * Get the current callstack as a comment that can be appended to a query.
+   *
+   * @param string $application_root
+   *   Application root to remove from the callstack dump.
+   *
+   * @param array $extras
+   *   Any application specific information that needs to be dumped.
+   *
+   * @return string
+   */
+  public function GetCallstackAsComment($application_root, array $extras = array()) {
+    $trim = strlen($application_root);
+    $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
+    // Remove last items.
+    $trace = array_splice($trace, 2);
+    $comment = PHP_EOL . PHP_EOL;
+    foreach ($extras as $extra) {
+      $comment .= $extra . PHP_EOL;
+    }
+    $uri = (isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : 'none') ;
+    $uri = preg_replace("/[^a-zA-Z0-9]/i", "_", $uri);
+    $comment .= '-- url:' . $uri . PHP_EOL;
+    foreach ($trace as $t) {
+      $function = isset($t['function']) ? $t['function'] : '';
+      $file = '';
+      if(isset($t['file'])) {
+        $len = strlen($t['file']);
+        if ($len > $trim) {
+          $file = substr($t['file'], $trim, $len - $trim) . " [{$t['line']}]";
+        }
+      }
+      $comment .= '-- ' . str_pad($function, 35) . '  ' . $file . PHP_EOL;
+    }
+    $comment .= PHP_EOL;
+    return $comment;
+  }
+  /**
+   * This is a helper method to rethrow an Exception if the execution
+   * of a PDOStatement fails.
+   *
+   * Sometimes, as a result of a PDO Statement execution error
+   * the error itself will be found in the connection and no in the statement.
+   *
+   */
+  public function ThrowPdoException(Statement &$statement = NULL, \PDOException $e = NULL) {
+    // This is what a SQL Server PDO "no error" looks like.
+    $null_error = array(0 => '00000', 1 => NULL, 2 => NULL);
+    $error_info_connection = $this->errorInfo();
+    if ($error_info_connection == $null_error && $e !== NULL) {
+      throw $e;
+    }
+    $error_info_statement =  !empty($statement) ? $statement->errorInfo() : $null_error;
+    // TODO: Concatenate error information when both connection
+    // and statement error info are valid.
+    // We rebuild a message formatted in the same way as PDO.
+    $error_info = ($error_info_connection === $null_error) ? $error_info_statement : $error_info_connection;
+    $code = $e && is_numeric($e->getCode()) ? $e->getCode() : 0;
+    $exception = new PDOException("SQLSTATE[" . $error_info[0] . "]: General error " . $error_info[1] . ": " . $error_info[2], $code, $e);
+    $exception->errorInfo = $error_info;
+    unset($statement);
+    throw $exception;
+  }
+  /**
+   * Generate a sequence
+   *
+   * @param int $existing
+   *   The sequence value must be greater than this value.
+   * @param string $name
+   *   Name of the sequence.
+   * @throws \Exception
+   * @return mixed
+   */
+  public function nextId($min = 0, $name = 'default') {
+
+    if (!is_int($min)) {
+      throw new \InvalidArgumentException("Minimum id value must be an integer: $min");
+    }
+
+    // The sequence name must be unique for this installation.
+    $sequence_name = 'seq_' . $name;
+
+    try {
+      $next_id = $this->query_execute("SELECT NEXT VALUE FOR $sequence_name")->fetchField();
+    }
+    catch (\Exception $e) {
+      // Create the sequence starting at $min + 2,
+      // because $min + 1 is already being used in this request.
+      $start = $min + 2;
+      // The "first id" is the same as the minimum possible
+      // value, because the minimum for MSSQL is inclusive, while
+      // this function's definition $min is exclusive (must
+      // be greater.
+      $next_id = $min + 1;
+      $this->query_execute("CREATE SEQUENCE $sequence_name START WITH $start INCREMENT BY 1 MINVALUE $next_id");
+    }
+
+    // If the retrieve id is smaller or equal to de existent,
+    // restart the sequence to the provided number.
+    if ($next_id <= $min) {
+      $min++;
+      $this->query_execute("ALTER SEQUENCE $sequence_name RESTART WITH $min");
+      $next_id = $this->query_execute("SELECT NEXT VALUE FOR $sequence_name")->fetchColumn();
+    }
+
+    return $next_id;
+  }
+}
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ConnectionSettings.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ConnectionSettings.php
new file mode 100644
index 00000000..895c48d5
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ConnectionSettings.php
@@ -0,0 +1,154 @@
+<?php
+namespace mssql;
+use \PDO as PDO;
+/**
+ * Global settings for the driver.
+ */
+class ConnectionSettings {
+  private $_defaultIsolationLevel;
+  private $_defaultDirectQueries;
+  private $_defaultStatementCaching;
+  private $_statementCachingMode;
+  private $_appendStackComments;
+  private $_additionalDSN;
+  /**
+   * Default settings for the dabase driver.
+   *
+   * @var array
+   */
+  private static $default_driver_settings = [
+        'default_isolation_level' => FALSE,
+        'default_direct_queries' => TRUE,
+        'default_statement_caching' => FALSE,
+        'statement_caching_mode' => 'disabled',
+        'append_stack_comments' => FALSE,
+        'additional_dsn' => []
+      ];
+  /**
+   * Checks for a valid setting in the list of allowed values.
+   *
+   * @param mixed $value
+   * @param mixed $value
+   * @param array $allowed
+   */
+  private function CheckValid($name, $value, array $allowed) {
+    if (!in_array($value, $allowed)) {
+      throw new \Exception("Invalid driver setting for $name");
+    }
+    return $value;
+  }
+  /**
+   * Builds a DriverSettings instance from custom settings. Missing settings are merged
+   * from the application settings.
+   *
+   * @param mixed $configuration
+   */
+  public static function instanceFromData($configuration = array()) {
+    $configuration = array_merge(static::$default_driver_settings, $configuration);
+    return new ConnectionSettings($configuration);
+  }
+  /**
+   * Construct an instance of DriverSettings.
+   */
+  private function __construct($configuration) {
+    $this->_defaultIsolationLevel = $this->CheckValid('default_isolation_level', $configuration['default_isolation_level'], array(
+        FALSE,
+        PDO::SQLSRV_TXN_READ_UNCOMMITTED,
+        PDO::SQLSRV_TXN_READ_COMMITTED,
+        PDO::SQLSRV_TXN_REPEATABLE_READ,
+        PDO::SQLSRV_TXN_SNAPSHOT,
+        PDO::SQLSRV_TXN_SERIALIZABLE,
+      ));
+    $this->_defaultDirectQueries = $this->CheckValid('default_direct_queries', $configuration['default_direct_queries'], array(TRUE, FALSE));
+    $this->_defaultStatementCaching = $this->CheckValid('default_statement_caching', $configuration['default_statement_caching'], array(TRUE, FALSE));
+    $this->_statementCachingMode = $this->CheckValid('statement_caching_mode', $configuration['statement_caching_mode'], array('disabled', 'on-demand', 'always'));
+    $this->_appendStackComments = $this->CheckValid('append_stack_comments', $configuration['append_stack_comments'], array(TRUE, FALSE));
+    $this->_additionalDSN = $configuration['additional_dsn'];
+  }
+  /**
+   * Export current driver configuration.
+   *
+   * @return array
+   */
+  public function exportConfiguration() {
+    return array(
+        'default_isolation_level' => $this->GetDefaultIsolationLevel(),
+        'default_direct_queries' => $this->GetDefaultDirectQueries(),
+        'statement_caching_mode' => $this->GetStatementCachingMode(),
+        'append_stack_comments' => $this->GetAppendCallstackComment(),
+        'default_statement_caching' => $this->GetDeafultStatementCaching(),
+        'additional_dsn' => $this->GetAdditionalDSN(),
+      );
+  }
+  /**
+   * Isolation level used for implicit transactions.
+   */
+  public function GetAdditionalDSN() {
+    return $this->_additionalDSN;
+  }
+  /**
+   * Isolation level used for implicit transactions.
+   */
+  public function GetDefaultIsolationLevel() {
+    return $this->_defaultIsolationLevel;
+  }
+  /**
+   * PDO Constant names do not match 1-to-1 the transaction names that
+   * need to be used in SQL.
+   *
+   * @return mixed
+   */
+  public function GetDefaultTransactionIsolationLevelInStatement() {
+    return str_replace('_', ' ', $this->GetDefaultIsolationLevel());
+  }
+  /**
+   * Default query preprocess.
+   *
+   * @return mixed
+   */
+  public function GetDeafultStatementCaching() {
+    return $this->_defaultStatementCaching;
+  }
+  /**
+   * Wether to run all statements in direct query mode by default.
+   */
+  public function GetDefaultDirectQueries() {
+    return $this->_defaultDirectQueries;
+  }
+  /**
+   * Enable appending of PHP stack as query comments.
+   */
+  public function GetAppendCallstackComment() {
+    return $this->_appendStackComments;
+  }
+  /**
+   * Experimental statement caching for PDO prepared statement
+   * reuse.
+   *
+   * 'disabled' => Never use statement caching.
+   * 'on-demand' => Only use statement caching when implicitly set in a Context.
+   * 'always' => Always use statement caching.
+   *
+   */
+  public function GetStatementCachingMode() {
+    return $this->_statementCachingMode;
+  }
+
+  /**
+   * Build the connection string.
+   * 
+   * @param array $options
+   * 
+   * @return string
+   */
+  public function buildDSN(array $options) {
+    // Merge the original options with the
+    // aditional DSN settings.
+    $options = $options + $this->GetAdditionalDSN();
+    $dsn = 'sqlsrv:';
+    foreach ($options as $key => $value) {
+      $dsn .= (empty($key) ? '' : "{$key}=") . $value . ';';
+    }
+    return $dsn;
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/DoomedTransactionException.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/DoomedTransactionException.php
new file mode 100644
index 00000000..df331f27
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/DoomedTransactionException.php
@@ -0,0 +1,5 @@
+<?php
+namespace mssql;
+class DoomedTransactionException extends \Exception
+{
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ExtensionData.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ExtensionData.php
new file mode 100644
index 00000000..af2754d5
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/ExtensionData.php
@@ -0,0 +1,48 @@
+<?php
+
+namespace mssql;
+
+use mssql\Component\SettingsManager;
+use mssql\Component\EmtpySetting;
+
+class ExtensionData extends SettingsManager {
+
+  /**
+   * The name of the Extension.
+   */
+  public function Name() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function Version() {
+    return parent::CallMethod(__FUNCTION__, array(),func_get_args());
+  }
+
+  public function ClassName() {
+    return parent::CallMethod(__FUNCTION__, array(),func_get_args());
+  }
+
+  public function Constants() {
+    return parent::CallMethod(__FUNCTION__, array(),func_get_args());
+  }
+
+  public function Dependencies() {
+    return parent::CallMethod(__FUNCTION__, array(),func_get_args());
+  }
+
+  public function Functions() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function IniEntries() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function Persistent() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function Temporary() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/EngineVersion.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/EngineVersion.php
new file mode 100644
index 00000000..ff994df5
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/EngineVersion.php
@@ -0,0 +1,47 @@
+<?php
+
+namespace mssql\Scheme;
+
+use mssql\Component\SettingsManager;
+
+use mssql\Connection;
+
+class EngineVersion extends SettingsManager {
+
+  /**
+   * Get an instance of EngineVersion
+   *
+   * @param Connection $cnn
+   *   The connection to use
+   *
+   * @return EngineVersion
+   */
+  public static function Get(Connection $cnn) {
+    $data = $cnn
+    ->query_execute(<<< EOF
+    SELECT CONVERT (varchar,SERVERPROPERTY('productversion')) AS VERSION,
+    CONVERT (varchar,SERVERPROPERTY('productlevel')) AS LEVEL,
+    CONVERT (varchar,SERVERPROPERTY('edition')) AS EDITION
+EOF
+    )->fetchAssoc();
+
+    $result = new EngineVersion();
+    $result->Version($data['VERSION']);
+    $result->Level($data['LEVEL']);
+    $result->Edition($data['EDITION']);
+
+    return $result;
+  }
+
+  public function Version() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function Level() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  public function Edition() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/UserOptions.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/UserOptions.php
new file mode 100644
index 00000000..1daf49d6
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme/UserOptions.php
@@ -0,0 +1,136 @@
+<?php
+
+namespace mssql\Scheme;
+
+use mssql\Component\SettingsManager;
+
+use mssql\Connection;
+
+class UserOptions extends SettingsManager {
+
+  /**
+   * Get an instance of UserOptions
+   *
+   * @param Connection $connection
+   *
+   * @return UserOptions
+   */
+  public static function Get(Connection $connection) {
+
+    $data = new UserOptions();
+
+    try {
+
+      $result = $connection->query_execute('DBCC UserOptions')->fetchAllKeyed();
+
+      // These are not available on AZURE ?
+      $data->QuotedIdentifier($result['quoted_identifier']);
+      $data->AnsiNullDefaultOn($result['ansi_null_dflt_on']);
+      $data->AnsiWarnings($result['ansi_warnings']);
+      $data->AnsiPadding($result['ansi_padding']);
+      $data->AnsiNulls($result['ansi_nulls']);
+      $data->ConcatNullYieldsNull( $result['concat_null_yields_null']);
+
+    }
+    catch (\Exception $e) {
+
+      // Azure compatibility.
+      $result = [];
+      $result['textsize'] =  $connection->query_execute("SELECT @@TEXTSIZE AS [textsize]")->fetchColumn();
+      $result['language'] =  $connection->query_execute("SELECT @@LANGUAGE AS [language]")->fetchColumn();
+      $result['dateformat'] =  $connection->query_execute("SELECT [dateformat] FROM [sys].[syslanguages] WHERE [langid] = @@LANGID")->fetchColumn();
+      $result['datefirst'] =  $connection->query_execute("select @@DATEFIRST as [datefirst]")->fetchColumn();
+      $result['lock_timeout'] =  $connection->query_execute("select @@lock_timeout as [lock_timeout]")->fetchColumn();
+
+      $query = <<<EOT
+        SELECT CASE transaction_isolation_level 
+        WHEN 0 THEN 'Unspecified' 
+        WHEN 1 THEN 'Read Uncomitted' 
+        WHEN 2 THEN 'Read comitted' 
+        WHEN 3 THEN 'Repeatable' 
+        WHEN 4 THEN 'Serializable' 
+        WHEN 5 THEN 'Snapshot' END AS TRANSACTION_ISOLATION_LEVEL 
+        FROM sys.dm_exec_sessions 
+        where session_id = @@SPID
+EOT;
+
+      $result['isolation level'] =  $connection->query_execute($query)->fetchColumn();
+
+    }
+
+    // These fields are common to both MSSQL and Azure
+    $data->TextSize($result['textsize']);
+    $data->Language($result['language']);
+    $data->DateFormat($result['dateformat']);
+    $data->DateFirst($result['datefirst']);
+    $data->LockTimeout($result['lock_timeout']);
+    $data->IsolationLevel($result['isolation level']);
+
+    return $data;
+  }
+
+  /**
+   * @return string
+   */
+  public function TextSize() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  /**
+   * @return string
+   */
+  public function Language() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  /**
+   * @return string
+   */
+  public function DateFormat() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args());
+  }
+
+  /**
+   * @return string
+   */
+  public function DateFirst() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function LockTimeout() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function QuotedIdentifier() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function Arithabort() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function AnsiNullDefaultOn() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function AnsiWarnings() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function AnsiPadding() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function AnsiNulls() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function ConcatNullYieldsNull() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+  public function IsolationLevel() {
+    return parent::CallMethod(__FUNCTION__, array(), func_get_args(), NULL);
+  }
+
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme.php
new file mode 100644
index 00000000..6a31efad
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Scheme.php
@@ -0,0 +1,894 @@
+<?php
+
+namespace mssql;
+
+use mssql\Settings\ConstraintTypes;
+use mssql\Settings\RecoveryModel;
+
+class Scheme {
+
+  /**
+   * Maximum length of a comment in SQL Server.
+   */
+  const COMMENT_MAX_BYTES = 7500;
+
+  /**
+   * Maximum index size when an XML index is present.
+   */
+  const INDEX_MAX_SIZE_WITH_XML = 128;
+
+  /**
+   * Connection.
+   *
+   * @var Connection
+   */
+  private $cnn = NULL;
+
+  public function __construct(Connection $cnn) {
+    $this->cnn = $cnn;
+  }
+
+  /**
+   * Get the SQL expression for a default value that can be embedded directly
+   * into a query.
+   *
+   * @param string $sqlsr_type
+   *   Sql server type: nvarchar, varbinary, char, ntext, etc.
+   * @param mixed $default
+   *   The default value.
+   */
+  public function DefaultValueExpression($sqlsr_type, $default) {
+    // The actual expression depends on the target data type as it might require conversions.
+    $result = is_string($default) ? $this->cnn->quote($default) : $default;
+    if (Utils::GetMSSQLType($sqlsr_type) == 'varbinary') {
+      $default = $this->cnn->quote($default);
+      $result = "CONVERT({$sqlsr_type}, {$default})";
+    }
+    return $result;
+  }
+
+  /**
+   * Verify if a in index exists in the database.
+   *
+   * @param string $table
+   *   Name of the table.
+   * @param string $index
+   *   Name of the index.
+   * @return bool
+   */
+  public function IndexExists($table, $index) {
+    return (bool) $this->cnn->query_execute('SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(:table) AND name = :name', array(
+      ':table' => $table,
+      ':name' => $index
+    ))->fetchField();
+  }
+
+  /**
+   * Check if a constraint exists.
+   *
+   * @param string $table
+   * @param ConstraintTypes $type
+   * @return bool
+   */
+  public function ConstraintExists($name, ConstraintTypes $type) {
+    return (bool) $this->cnn->query_execute("SELECT CASE WHEN OBJECT_ID(:name, :type) IS NULL THEN 0 ELSE 1 END", array(
+      ':type' => $type->__toString(),
+      ':name' => "dbo.[$name]"
+    ))->fetchField();
+  }
+
+  /**
+   * Drop an index, nothing to to if the index does not exists.
+   *
+   * @param string $table
+   *   Name of the table.
+   * @param string $index
+   *   Name of the index.
+   * @return void
+   */
+  public function IndexDrop($table, $index) {
+    if (!$this->IndexExists($table, $index)) {
+      // Nothing to do....
+      return;
+    }
+
+    $this->cnn->query_execute("DROP INDEX {$index} ON {$table}");
+  }
+
+  /**
+   * Drop a column form a table.
+   *
+   * @param string $table
+   *   Table name.
+   * @param string $column
+   *   Colum name.
+   *
+   * @return bool
+   */
+  public function FieldExists($table, $column) {
+    return $this->cnn
+        ->query_execute("SELECT 1 FROM INFORMATION_SCHEMA.columns WHERE table_name = '{$table}' AND column_name = '{$column}'")
+        ->fetchField() !== FALSE;
+  }
+
+  /**
+   * Drop a statistic
+   *
+   * @param string $table
+   *   Table name.
+   * @param string $statistics
+   *   Statistics name.
+   */
+  public function StatisticsDrop($table, $statistics) {
+    $this->cnn->query_execute("DROP STATISTICS {$table}.{$statistics}");
+  }
+
+  /**
+   * Check if a statistic already exists.
+   *
+   * @param string $table
+   * @param string $statistics
+   * @return bool
+   */
+  public function StatisticsExists($table, $statistics) {
+
+    $query = <<<EOF
+SELECT stat.name AS Statistics,
+ OBJECT_NAME(stat.object_id) AS Object,
+ COL_NAME(scol.object_id, scol.column_id) AS Column
+FROM sys.stats AS stat (NOLOCK) Join sys.stats_columns AS scol (NOLOCK)
+ ON stat.stats_id = scol.stats_id AND stat.object_id = scol.object_id
+ INNER JOIN sys.tables AS tab (NOLOCK) on tab.object_id = stat.object_id
+WHERE OBJECT_NAME(stat.object_id) = :table AND
+stat.name = :statistics
+EOF;
+
+    return $this->cnn
+      ->query_execute($query, array(
+          ':table' => $table,
+          ':statistics' => $statistics,
+        ))
+      ->fetchField() !== FALSE;
+  }
+
+  /**
+   * Check if a trigger exists.
+   *
+   * @param string $name
+   */
+  public function TriggerExists($name) {
+    return $this->cnn
+      ->query_execute("SELECT 1 FROM sys.triggers WHERE name = :name", array(':name' =>$name))
+      ->fetchField() !== FALSE;
+  }
+
+  /**
+   * Drop a triggerr.
+   *
+   * @param string $name
+   */
+  public function TriggeDrop($name) {
+    $this->cnn->query_execute("DROP TRGGER {$name}");
+  }
+
+  /**
+   * Check if a view exists.
+   *
+   * @param string $name
+   */
+  public function ViewExists($name) {
+    return $this->cnn
+    ->query_execute("SELECT 1 FROM INFORMATION_SCHEMA.views WHERE table_name = :name", array(':name' =>$name))
+    ->fetchField() !== FALSE;
+  }
+
+  /**
+   * Drop a View.
+   *
+   * @param string $name
+   */
+  public function ViewDrop($name) {
+    $this->cnn->query_execute("DROP VIEW {$name}");
+  }
+
+  /**
+   * Drop a Function.
+   *
+   * @param string $name
+   */
+  public function FunctionDrop($name) {
+    $this->cnn->query_execute("DROP FUNCTION {$name}");
+  }
+
+  /**
+   * Check if a table already exists.
+   *
+   * @param string $table
+   *   Name of the table.
+   *
+   * @return boolean
+   *   True if the table exists, false otherwise.
+   */
+  public function TableExists($table, $refresh = FALSE) {
+
+    $bin = $this->cnn->Cache('sqlsrv-table-exists');
+
+    if (!$bin->Get('@@preloaded')) {
+      foreach ($this->cnn->query_execute("SELECT table_name FROM INFORMATION_SCHEMA.tables") as $t) {
+        $bin->Set($t->table_name, TRUE);
+      }
+      $bin->Set('@@preloaded', TRUE);
+    }
+
+    if(!$refresh && $cache = $bin->Get($table)) {
+      return $cache->data;
+    }
+
+    // Temporary tables and regular tables cannot be verified in the same way.
+    $query = NULL;
+
+    if ($table[0] == '#') {
+      $table .= '%';
+      $query = "SELECT 1 FROM tempdb.sys.tables WHERE name like :table";
+    }
+    else {
+      $query = "SELECT 1 FROM INFORMATION_SCHEMA.tables WHERE table_name = :table";
+    }
+
+    $exists = $this->cnn->query_execute($query, [':table' => $table])->fetchField() !== FALSE;
+
+    if ($exists) {
+      $bin->Set($table, $exists);
+    }
+
+    return $exists;
+  }
+
+  /**
+   * Drop a table.
+   *
+   * @param string $table
+   *   Name of the table to drop.
+   *
+   * @return bool
+   */
+  public function TableDrop($table) {
+    if (!$this->TableExists($table, TRUE)) {
+      return FALSE;
+    }
+    $this->cnn->query_execute("DROP TABLE [{$table}]");
+    $this->cnn->Cache('sqlsrv-table-exists')->Clear($table);
+    return TRUE;
+  }
+
+  /**
+   * Check if a table already has an XML index.
+   *
+   * @param string $table
+   *   Name of the table.
+   */
+  public function TableHasXmlIndex($table) {
+    $info = $this->TableDetailsGet($table);
+    if (isset($info['indexes']) && is_array($info['indexes'])) {
+      foreach ($info['indexes'] as $name => $index) {
+        if (strcasecmp($index['type_desc'], 'XML') === 0) {
+          return $name;
+        }
+      }
+    }
+    return FALSE;
+  }
+
+  /**
+   * Return active default Schema.
+   */
+  public function GetDefaultSchema() {
+    if ($cache = $this->cnn->Cache('sqlsrv-engine')->Get('default_schema')) {
+      return $cache->data;
+    }
+    $result = $this->cnn->query_execute("SELECT SCHEMA_NAME()")->fetchField();
+    $this->cnn->Cache('sqlsrv-engine')->Set('default_schema', $result);
+    return $result;
+  }
+
+  /**
+   * Remove comments from an SQL statement.
+   * @see http://stackoverflow.com/questions/9690448/regular-expression-to-remove-comments-from-sql-statement
+   *
+   * @param mixed $sql
+   *  SQL statement to remove the comments from.
+   *
+   * @param mixed $comments
+   *  Comments removed from the statement
+   *
+   * @return string
+   */
+  public function removeSQLComments($sql, &$comments = NULL) {
+    $sqlComments = '@(([\'"]).*?[^\\\]\2)|((?:\#|--).*?$|/\*(?:[^/*]|/(?!\*)|\*(?!/)|(?R))*\*\/)\s*|(?<=;)\s+@ms';
+    /* Commented version
+    $sqlComments = '@
+    (([\'"]).*?[^\\\]\2) # $1 : Skip single & double quoted expressions
+    |(                   # $3 : Match comments
+    (?:\#|--).*?$    # - Single line comments
+    |                # - Multi line (nested) comments
+    /\*             #   . comment open marker
+    (?: [^/*]    #   . non comment-marker characters
+    |/(?!\*) #   . ! not a comment open
+    |\*(?!/) #   . ! not a comment close
+    |(?R)    #   . recursive case
+    )*           #   . repeat eventually
+    \*\/             #   . comment close marker
+    )\s*                 # Trim after comments
+    |(?<=;)\s+           # Trim after semi-colon
+    @msx';
+     */
+    $uncommentedSQL = trim(preg_replace($sqlComments, '$1', $sql));
+    if (is_array($comments)) {
+      preg_match_all($sqlComments, $sql, $comments);
+      $comments = array_filter($comments[ 3 ]);
+    }
+    return $uncommentedSQL;
+  }
+
+  /**
+   * Current configuration for the connection.
+   *
+   * @return Scheme\UserOptions
+   */
+  public function UserOptions() {
+    if ($cache = $this->cnn->Cache('sqlsrv-engine')->Get('UserOptions')) {
+      return $cache->data;
+    }
+    $data = Scheme\UserOptions::Get($this->cnn);
+    $this->cnn->Cache('sqlsrv-engine')->Set('UserOptions', $data);
+    return $data;
+  }
+
+  /**
+   * Get the description property of a table or column.
+   *
+   * @param string $table
+   *
+   * @param string $column
+   *
+   * @return string
+   */
+  public function CommentGet($table, $column = NULL) {
+
+    $arguments = array('MS_Description','Schema', $this->GetDefaultSchema(), 'Table', $table);
+    if (!empty($column)) {
+      $arguments[] = 'column';
+      $arguments[] = $column;
+    }
+
+    $args = call_user_func_array(Utils::class . '::GetExtendedProperty', $arguments);
+
+    $extended_property = $this->cnn->query_execute($args['query'], $args['args'])->fetchAssoc();
+    return $extended_property['value'];
+  }
+
+  /**
+   * Return the SQL statement to create or update a description.
+   */
+  public function CommentCreate($value, $table = NULL, $column = NULL) {
+
+    // Inside the same transaction, you won't be able to read uncommited extended properties
+    // leading to SQL Exception if calling sp_addextendedproperty twice on same object.
+    static $columns = array();
+
+    $schema = $this->GetDefaultSchema();
+    $name = 'MS_Description';
+
+    // Determine if a value exists for this database object.
+    $key = $schema . '.' .  $table . '.' . $column;
+    if(isset($columns[$key]) && $this->cnn->inTransaction()) {
+      $result = $columns[$key];
+    }
+    else {
+      $result = $this->CommentGet($table, $column);
+    }
+
+    $columns[$key] = $value;
+
+    // Only continue if the new value is different from the existing value.
+    $sql = '';
+    if ($result !== $value) {
+      if ($value == '') {
+        $sp = "sp_dropextendedproperty";
+        $sql = "EXEC " . $sp . " @name=N'" . $name;
+      }
+      else {
+        if ($result != '') {
+          $sp = "sp_updateextendedproperty";
+        }
+        else {
+          $sp = "sp_addextendedproperty";
+        }
+        $sql = "EXEC " . $sp . " @name=N'" . $name . "', @value=" . $value . "";
+      }
+      if (isset($schema)) {
+        $sql .= ",@level0type = N'Schema', @level0name = '". $schema ."'";
+        if (isset($table_prefixed)) {
+          $sql .= ",@level1type = N'Table', @level1name = '". $table_prefixed ."'";
+          if ($column !== NULL) {
+            $sql .= ",@level2type = N'Column', @level2name = '". $column ."'";
+          }
+        }
+      }
+    }
+
+    return $sql;
+  }
+
+  /**
+   * Invalidate cache for TableDetailsGet.
+   *
+   * @param string $table
+   */
+  public function TableDetailsInvalidate($table) {
+    $this->cnn->Cache('sqlsrv-tabledetails')->Clear($table);
+  }
+
+  /**
+  /**
+   * Database introspection: fetch technical information about a table.
+   *
+   *   An array with the following structure:
+   *   - blobs[]: Array of column names that should be treated as blobs in this table.
+   *   - identities[]: Array of column names that are identities in this table.
+   *   - identity: The name of the identity column
+   *   - columns[]: An array of specification details for the columns
+   *      - name: Column name.
+   *      - max_length: Maximum length.
+   *      - precision: Precision.
+   *      - collation_name: Collation.
+   *      - is_nullable: Is nullable.
+   *      - is_ansi_padded: Is ANSI padded.
+   *      - is_identity: Is identity.
+   *      - definition: If a computed column, the computation formulae.
+   *      - default_value: Default value for the column (if any).
+   *
+   * @param string $table
+   *
+   * @return array
+   */
+  public function TableDetailsGet($table) {
+    if ($cache = $this->cnn->Cache('sqlsrv-tabledetails')->Get($table)) {
+      // The correctness of this data is so important for the database layer
+      // to work, that we double check that it is - at least - valid.
+      if (isset($cache->data['columns']) && !empty($cache->data['columns'])) {
+        return $cache->data;
+      }
+    }
+
+    // We could adapt the current code to support temporary table introspection, but
+    // for now this is not supported.
+    if ($table[0] == '#') {
+      throw new \Exception('Temporary table introspection is not supported.');
+    }
+
+    $schema = $this->GetDefaultSchema();
+
+    // Initialize the information array.
+    $info = [
+     'identity' => NULL,
+     'identities' => [],
+     'columns' => [],
+     'columns_clean' => []
+    ];
+
+    // Don't use {} around information_schema.columns table.
+    $result = $this->cnn->query_execute("SELECT sysc.name, sysc.max_length, sysc.precision, sysc.collation_name,
+                    sysc.is_nullable, sysc.is_ansi_padded, sysc.is_identity, sysc.is_computed, TYPE_NAME(sysc.user_type_id) as type,
+                    syscc.definition,
+                    sm.[text] as default_value
+                    FROM sys.columns AS sysc
+                    INNER JOIN sys.syscolumns AS sysc2 ON sysc.object_id = sysc2.id and sysc.name = sysc2.name
+                    LEFT JOIN sys.computed_columns AS syscc ON sysc.object_id = syscc.object_id AND sysc.name = syscc.name
+                    LEFT JOIN sys.syscomments sm ON sm.id = sysc2.cdefault
+                    WHERE sysc.object_id = OBJECT_ID(:table)
+                    ",
+                  array(':table' => $schema . '.' . $table));
+
+    foreach ($result as $column) {
+      if ($column->type == 'varbinary') {
+        $info['blobs'][$column->name] = TRUE;
+      }
+
+      // Add the complete SQL Server type with length
+      $column->sqlsrv_type = $column->type;
+      if ($this->IsVariableLengthType($column->type)) {
+        if ($column->max_length == -1) {
+          $column->sqlsrv_type .= "(max)";
+        }
+        else {
+          $column->sqlsrv_type .= "($column->max_length)";
+        }
+      }
+
+      $info['columns'][$column->name] = (array) $column;
+      // Provide a clean list of columns that excludes the ones internally created by the
+      // database driver.
+      if (!(isset($column->name[1]) && substr($column->name, 0, 2) == "__")) {
+        $info['columns_clean'][$column->name] = (array) $column;
+      }
+      if ($column->is_identity) {
+        $info['identities'][$column->name] = $column->name;
+        $info['identity'] = $column->name;
+      }
+    }
+
+    // We should have some column data here, otherwise there is a
+    // chance that the table does not exist.
+    if (empty($info['columns']) && !$this->TableExists($table)) {
+      throw new \Exception("Table {$table} does not exist.", 25663);
+    }
+
+    // If we have computed columns, it is important to know what other columns they depend on!
+    $column_names = array_keys($info['columns']);
+    $column_regex = implode('|', $column_names);
+    foreach($info['columns'] as &$column) {
+      $dependencies = array();
+      if (!empty($column['definition'])) {
+        $matches = array();
+        if (preg_match_all("/\[[{$column_regex}\]]*\]/", $column['definition'], $matches) > 0) {
+          $dependencies = array_map(function($m) { return trim($m, "[]"); }, array_shift($matches));
+        }
+      }
+      $column['dependencies'] = array_flip($dependencies);
+    }
+
+    // Now introspect information about indexes
+    $result =  $this->cnn->query_execute("select tab.[name]  as [table_name],
+         idx.[name]  as [index_name],
+         allc.[name] as [column_name],
+         idx.[type_desc],
+         idx.[is_unique],
+         idx.[data_space_id],
+         idx.[ignore_dup_key],
+         idx.[is_primary_key],
+         idx.[is_unique_constraint],
+         idx.[fill_factor],
+         idx.[is_padded],
+         idx.[is_disabled],
+         idx.[is_hypothetical],
+         idx.[allow_row_locks],
+         idx.[allow_page_locks],
+         idxc.[is_descending_key],
+         idxc.[is_included_column],
+         idxc.[index_column_id],
+         idxc.[key_ordinal]
+    FROM sys.[tables] as tab
+    INNER join sys.[indexes]       idx  ON tab.[object_id] =  idx.[object_id]
+    INNER join sys.[index_columns] idxc ON idx.[object_id] = idxc.[object_id] and  idx.[index_id]  = idxc.[index_id]
+    INNER join sys.[all_columns]   allc ON tab.[object_id] = allc.[object_id] and idxc.[column_id] = allc.[column_id]
+    WHERE tab.object_id = OBJECT_ID(:table)
+    ORDER BY tab.[name], idx.[index_id], idxc.[index_column_id]
+                    ",
+                  array(':table' => $schema . '.' . $table));
+
+    foreach ($result as $index_column) {
+      if (!isset($info['indexes'][$index_column->index_name])) {
+        $ic = clone $index_column;
+        // Only retain index specific details.
+        unset($ic->column_name);
+        unset($ic->index_column_id);
+        unset($ic->is_descending_key);
+        unset($ic->table_name);
+        unset($ic->key_ordinal);
+        $info['indexes'][$index_column->index_name] = (array) $ic;
+        if ($index_column->is_primary_key) {
+          $info['primary_key_index'] = $ic->index_name;
+        }
+      }
+
+      $index = &$info['indexes'][$index_column->index_name];
+      $index['columns'][$index_column->key_ordinal] = array(
+           'name' => $index_column->column_name,
+           'is_descending_key' => $index_column->is_descending_key,
+           'key_ordinal' => $index_column->key_ordinal,
+         );
+
+      // Every columns keeps track of what indexes it is part of.
+      $info['columns'][$index_column->column_name]['indexes'][] = $index_column->index_name;
+      if (isset($info['columns_clean'][$index_column->column_name])) {
+        $info['columns_clean'][$index_column->column_name]['indexes'][] = $index_column->index_name;
+      }
+    }
+
+    $this->cnn->Cache('sqlsrv-tabledetails')->Set($table, $info);
+    return $info;
+  }
+
+  /**
+   * Retrieve an array of field specs from
+   * an array of field names.
+   *
+   * @param string $table
+   *   Name of the table.
+   * @param array|string $fields
+   *   Name of column or list of columns to retrieve information about.
+   */
+  public function ColumnDetailsGet($table, $fields) {
+    $info = $this->TableDetailsGet($table);
+    if (is_array($fields)) {
+      $result = array();
+      foreach ($fields as $field) {
+        $result[$field] = $info['columns'][$field];
+      }
+      return $result;
+    }
+    else {
+      return $info['columns'][$fields];
+    }
+  }
+
+  /**
+   * Summary of EngineVersion
+   *
+   * @return Scheme\EngineVersion
+   */
+  public function EngineVersion() {
+    if ($cache = $this->cnn->Cache('sqlsrv-engine')->Get('EngineVersion')) {
+      return $cache->data;
+    }
+    $version = Scheme\EngineVersion::Get($this->cnn);
+    $this->cnn->Cache('sqlsrv-engine')->Set('EngineVersion', $version);
+    return $version;
+  }
+
+  /**
+   * Retrieve Major engine version number as integer.
+   *
+   * @return int
+   */
+  public function EngineVersionNumber() {
+    $version = $this->EngineVersion();
+    $parts = explode($version->Version(), '.');
+    return (int) reset($parts);
+  }
+
+  /**
+   * Find if a table function exists.
+   *
+   * @param $function
+   *   Name of the function.
+   *
+   * @return
+   *   True if the function exists, false otherwise.
+   */
+  public function functionExists($function) {
+    // FN = Scalar Function
+    // IF = Inline Table Function
+    // TF = Table Function
+    // FS | AF = Assembly (CLR) Scalar Function
+    // FT | AT = Assembly (CLR) Table Valued Function
+    return $this->cnn
+      ->query_execute("SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID('" . $function . "') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT', N'AF')")
+      ->fetchField() !== FALSE;
+  }
+
+  /**
+   * Check if CLR is enabled. Required to run GROUP_CONCAT.
+   *
+   * @return bool
+   */
+  public function CLREnabled() {
+    return $this->cnn
+        ->query_execute("SELECT CONVERT(int, [value]) as [enabled] FROM sys.configurations WHERE name = 'clr enabled'")
+        ->fetchField() !== 0;
+  }
+
+  /**
+   * Check if a column is of variable length.
+   */
+  private function IsVariableLengthType($type) {
+    $types = array('nvarchar' => TRUE, 'ntext' => TRUE, 'varchar' => TRUE, 'varbinary' => TRUE, 'image' => TRUE);
+    return isset($types[$type]);
+  }
+
+  /**
+   * Estimates the row size of a clustered index.
+   *
+   * @see https://msdn.microsoft.com/en-us/library/ms178085.aspx
+   *
+   * @return int
+   *
+   */
+  public function calculateClusteredIndexRowSizeBytes($table, $fields, $unique = TRUE) {
+    // The fields must already be in the database to retrieve their real size.
+    $info = $this->TableDetailsGet($table);
+
+    // Specify the number of fixed-length and variable-length columns
+    // and calculate the space that is required for their storage.
+    $num_cols = count($fields);
+    $num_variable_cols = 0;
+    $max_var_size = 0;
+    $max_fixed_size = 0;
+    foreach ($fields as $field) {
+      if ($this->IsVariableLengthType($info['columns'][$field]['type'])) {
+        $num_variable_cols++;
+        $max_var_size += $info['columns'][$field]['max_length'];
+      }
+      else {
+        $max_fixed_size += $info['columns'][$field]['max_length'];
+      }
+    }
+
+    // If the clustered index is nonunique, account for the uniqueifier column.
+    if (!$unique) {
+      $num_cols++;
+      $num_variable_cols++;
+      $max_var_size += 4;
+    }
+
+    // Part of the row, known as the null bitmap, is reserved to manage column nullability. Calculate its size.
+    $null_bitmap = 2 + (($num_cols + 7) / 8);
+
+    // Calculate the variable-length data size.
+    $variable_data_size = empty($num_variable_cols) ? 0 : 2 + ($num_variable_cols * 2) + $max_var_size;
+
+    // Calculate total row size.
+    $row_size = $max_fixed_size + $variable_data_size + $null_bitmap + 4;
+
+    return $row_size;
+  }
+
+  /**
+   * Create a database.
+   *
+   * @param string $name
+   *   Name of the database.
+   * @param string $collation
+   *   Collation or empty for the default engine collation.
+   */
+  public function DatabaseCreate($name, $collation = NULL) {
+    // Create the database.
+    if ($collation !== NULL) {
+      $this->cnn->query_execute("CREATE DATABASE $name COLLATE " . $collation);
+    }
+    else {
+      $this->cnn->query_execute("CREATE DATABASE $name");
+    }
+  }
+
+  /**
+   * Change the database recovery model.
+   *
+   * @param RecoveryModel $model
+   *   The model to update to.
+   */
+  public function setRecoveryModel(RecoveryModel $model) {
+    $this->cnn->query("ALTER {$this->cnn->options['name']} model SET RECOVERY {$model->__toString()}");
+  }
+
+  /**
+   * Return size information
+   *
+   * @param string $database
+   *   Name of the database.
+   * @return mixed
+   */
+  public function getSizeInfo($database) {
+
+    $sql = <<< EOF
+      SELECT
+    DB_NAME(db.database_id) DatabaseName,
+    (CAST(mfrows.RowSize AS FLOAT)*8)/1024 RowSizeMB,
+    (CAST(mflog.LogSize AS FLOAT)*8)/1024 LogSizeMB,
+    (CAST(mfstream.StreamSize AS FLOAT)*8)/1024 StreamSizeMB,
+    (CAST(mftext.TextIndexSize AS FLOAT)*8)/1024 TextIndexSizeMB
+FROM sys.databases db
+    LEFT JOIN (SELECT database_id, SUM(size) RowSize FROM sys.master_files WHERE type = 0 GROUP BY database_id, type) mfrows ON mfrows.database_id = db.database_id
+    LEFT JOIN (SELECT database_id, SUM(size) LogSize FROM sys.master_files WHERE type = 1 GROUP BY database_id, type) mflog ON mflog.database_id = db.database_id
+    LEFT JOIN (SELECT database_id, SUM(size) StreamSize FROM sys.master_files WHERE type = 2 GROUP BY database_id, type) mfstream ON mfstream.database_id = db.database_id
+    LEFT JOIN (SELECT database_id, SUM(size) TextIndexSize FROM sys.master_files WHERE type = 4 GROUP BY database_id, type) mftext ON mftext.database_id = db.database_id
+    WHERE DB_NAME(db.database_id) = :database
+EOF
+;
+    // Database is defaulted from active connection.
+    $result = NULL;
+    try {
+      $result = $this->cnn->query_execute($sql, array(':database' => $database))->fetchObject();
+    }
+    catch (\Exception $e) {
+      // This might not work on azure...
+    }
+
+    // There is a chance that this might not return the database size, so
+    // try another strategy.
+    if (empty($result->RowSizeMB)) {
+      $sql = <<< EOF
+      SELECT (SUM(reserved_page_count) * 8192) / 1024 / 1024 AS DbSizeInMB
+      FROM    sys.dm_db_partition_stats
+EOF;
+      $result->RowSizeMB = $this->cnn->query_execute($sql)->fetchField();
+    }
+
+    // Try and get the number of tables
+    $sql = <<< EOF
+      SELECT COUNT(*) from information_schema.tables
+      WHERE table_type = 'base table'
+EOF;
+
+    $result->TableCount = $this->cnn->query_execute($sql)->fetchField();
+
+    return $result;
+
+  }
+  /**
+   * Get general database information.
+   *
+   * @param string $database
+   *   Name of the database.
+   *
+   * @return mixed
+   */
+  public function getDatabaseInfo($database) {
+    static $result;
+    if (isset($result)) {
+      return $result;
+    }
+    $sql = <<< EOF
+      select name
+        , db.snapshot_isolation_state
+        , db.snapshot_isolation_state_desc
+        , db.is_read_committed_snapshot_on
+        , db.recovery_model
+        , db.recovery_model_desc
+        , db.collation_name
+    from sys.databases db
+    WHERE DB_NAME(db.database_id) = :database
+EOF
+;
+    // Database is defaulted from active connection.
+    $result = $this->cnn->query_execute($sql, array(':database' => $database))->fetchObject();
+    return $result;
+  }
+  /**
+   * Get the collation of current connection wether
+   * it has or not a database defined in it.
+   *
+   * @param string $database
+   *   Name of the database.
+   * @param string $schema
+   *   Name of the schema.
+   * @param string $table
+   *   Name of the table.
+   * @param string $column
+   *   Name of the column.
+   *
+   * @return string
+   */
+  public function getCollation($database, $schema, $table = NULL, $column = NULL) {
+    // No table or column provided, then get info about
+    // database (if exists) or server defaul collation.
+    if (empty($table) && empty($column)) {
+      // Database is defaulted from active connection.
+      if (!empty($database)) {
+        // Default collation for specific table.
+        $sql = "SELECT CONVERT (varchar, DATABASEPROPERTYEX('$database', 'collation'))";
+        return $this->cnn->query_execute($sql)->fetchField();
+      }
+      else {
+        // Server default collation.
+        $sql = "SELECT SERVERPROPERTY ('collation') as collation";
+        return $this->cnn->query_execute($sql)->fetchField();
+      }
+    }
+    $sql = <<< EOF
+      SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, COLLATION_NAME, DATA_TYPE
+        FROM INFORMATION_SCHEMA.COLUMNS
+        WHERE TABLE_SCHEMA = ':schema'
+        AND TABLE_NAME = ':table'
+        AND COLUMN_NAME = ':column'
+EOF
+;
+    $params = array();
+    $params[':schema'] = $schema;
+    $params[':table'] = $table;
+    $params[':column'] = $column;
+    $result = $this->cnn->query_execute($sql, $params)->fetchObject();
+    return $result->COLLATION_NAME;
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/ConstraintTypes.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/ConstraintTypes.php
new file mode 100644
index 00000000..e5ee6731
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/ConstraintTypes.php
@@ -0,0 +1,40 @@
+<?php
+
+namespace mssql\Settings;
+
+use \mssql\Component\Enum;
+
+/**
+ * Constraint types for SQL Server.
+ */
+class ConstraintTypes extends Enum {
+  /**
+   * CHECK constraint
+   */
+  const CCHECK = 'C';
+
+  /**
+   * DEFAULT (constraint or stand-alone)
+   */
+  const CDEFAULT = 'D';
+
+  /**
+   * FOREIGN KEY constraint
+   */
+  const CFOREIGNKEY = 'F';
+
+  /**
+   * PRIMARY KEY constraint
+   */
+  const CPRIMARYKEY = 'P';
+
+  /**
+   * Rule (old-style, stand-alone)
+   */
+  const CRULE = 'R';
+
+  /**
+   * UNIQUE constraint
+   */
+  const CUNIQUE = 'UQ';
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/RecoveryModel.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/RecoveryModel.php
new file mode 100644
index 00000000..c02a6818
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/RecoveryModel.php
@@ -0,0 +1,11 @@
+<?php
+
+namespace mssql\Settings;
+
+use \mssql\Component\Enum;
+
+class RecoveryModel extends Enum {
+  const Full = 'FULL';
+  const BulkLogged = 'BULK_LOGGED';
+  const Simple = 'SIMPLE';
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionIsolationLevel.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionIsolationLevel.php
new file mode 100644
index 00000000..738cedff
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionIsolationLevel.php
@@ -0,0 +1,18 @@
+<?php
+
+namespace mssql\Settings;
+
+use mssql\Component\Enum;
+
+/**
+ * Available transaction isolation levels for MSSQL.
+ */
+class TransactionIsolationLevel extends Enum {
+  const ReadUncommitted = 'READ UNCOMMITTED';
+  const ReadCommitted = 'READ COMMITTED';
+  const RepeatableRead = 'REPEATABLE READ';
+  const Snapshot = 'SNAPSHOT';
+  const Serializable = 'SERIALIZABLE';
+  const Chaos = 'CHAOS';
+  const Ignore = 'IGNORE';
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionScopeOption.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionScopeOption.php
new file mode 100644
index 00000000..cb930cf9
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Settings/TransactionScopeOption.php
@@ -0,0 +1,11 @@
+<?php
+
+namespace mssql\Settings;
+
+use mssql\Component\Enum;
+
+class TransactionScopeOption extends Enum {
+  const RequiresNew = 'RequiresNew';
+  const Supress = 'Supress';
+  const Required = 'Required';
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Statement.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Statement.php
new file mode 100644
index 00000000..84319818
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Statement.php
@@ -0,0 +1,368 @@
+<?php
+
+namespace mssql;
+
+use PDO as PDO;
+use PDOException as PDOException;
+use PDOStatement as PDOStatement;
+
+/**
+ * Turbocharged Statement class to work with MSSQL server.
+ */
+class Statement extends PDOStatement implements \Countable {
+  /**
+   * An MD5 signature for the query
+   *
+   * @var string
+   */
+  protected $query_signature;
+
+  /**
+   * Reference to the Connection
+   *
+   * @var Connection
+   */
+  protected $cnn = NULL;
+
+  /**
+   * Special PDO options
+   *
+   * @var array
+   */
+  protected $options = NULL;
+
+  /**
+   * ODBC Codes for integrity constraint violation errors.
+   *
+   * @var array
+   */
+  protected $INTEGRITY_VIOLATION_CONSTRAINT_CODES = ['23000'];
+
+  /**
+   * ODBC Codes for failed communcation link/dropped connections
+   *
+   * @var array
+   */
+  protected $CONNECTION_FAILED_CODES = ['08S01'];
+
+  /**
+   * Maximum number a failed query
+   * can be retried in case of failure
+   * due to integrity constraint violations
+   * or dropped connections.
+   */
+  const RETRY_MAX = 3;
+
+  /**
+   * Delay between retries in seconds.
+   *
+   * This effective delay is the product
+   * of this constant and the current retry
+   * count.
+   */
+  const RETRY_DELAY = 0.4;
+
+  /**
+   * Return the number of rows.
+   *
+   * @return int
+   */
+  public function count() {
+    return $this->rowCount();
+  }
+
+  /**
+   * Set a reference to the connection.
+   *
+   * @param Connection $cnn
+   */
+  public function SetConnection(Connection $cnn, array $options = []) {
+    // Custom PDO options
+    $this->options = array_merge([
+         Connection::PDO_RESILIENTRETRY => FALSE,
+         Connection::PDO_RETRYONINTEGRITYVIOLATION => FALSE
+         ],
+         $options
+    );
+    $this->cnn = $cnn;
+  }
+
+  /**
+   * Get parameters bound to this statement, useful for debugging purposes.
+   *
+   * @return string[]
+   */
+  public function &GetBoundParameters() {
+    return $this->boundParams;
+  }
+
+  /**
+   * @var string[] $boundParams - array of arrays containing values that have been bound to the query as parameters
+   */
+  protected $boundParams = array();
+
+  /**
+   * Overrides the default \PDOStatement method to add the named parameter and it's reference to the array of bound
+   * parameters - then accesses and returns parent::bindParam method
+   *
+   * @param string $param
+   * @param mixed $value
+   * @param int $datatype
+   * @param int $length
+   * @param mixed $driverOptions
+   * @return bool
+   */
+  public function bindParam($param, &$value, $datatype = PDO::PARAM_STR, $length = 0, $driverOptions = FALSE) {
+    $this->boundParams[$param] = array(
+          "value"       => &$value
+        , "datatype"    => $datatype
+    );
+
+    if (empty($driverOptions)) {
+      return parent::bindParam($param, $value, $datatype, $length);
+    }
+    else {
+      return parent::bindParam($param, $value, $datatype, $length, $driverOptions);
+    }
+  }
+
+  /**
+   * Overrides the default \PDOStatement method to add the named parameter and it's value to the array of bound values
+   * - then accesses and returns parent::bindValue method
+   *
+   * @param string $param
+   * @param string $value
+   * @param int $datatype
+   * @return bool
+   */
+  public function bindValue($param, $value, $datatype = PDO::PARAM_STR) {
+    $this->boundParams[$param] = array(
+          "value"       => $value
+        , "datatype"    => $datatype
+    );
+
+    return parent::bindValue($param, $value, $datatype);
+  }
+
+  /**
+   * Cached version of getColumnMeta().
+   *
+   * Who knows why this was always profiled as being
+   * a memory hog, probably due some problem with
+   * the PDO driver.
+   *
+   * @return mixed
+   */
+  protected function getColumnMetaCustom() {
+    $meta = FALSE;
+    if ($cache = $this->cnn->Cache('sqlsrv_meta')->Get($this->query_signature)) {
+      return $cache->data;
+    }
+    // Just some safety to account for some schema
+    // changes.
+    $meta = [];
+    for ($i = 0, $count = $this->columnCount(); $i < $count; $i++) {
+      $meta[$i] = $this->getColumnMeta($i);
+      $meta[$i]['sqlsrv_type'] = explode(' ', $meta[$i]['sqlsrv:decl_type'])[0];
+    }
+    $this->cnn->Cache('sqlsrv_meta')->Set($this->query_signature, $meta);
+    return $meta;
+  }
+
+  /**
+   * Make sure that SQL Server types are properly binded to
+   * PHP types.
+   *
+   * Only need when using CLIENT BASED PREFETCH.
+   *
+   */
+  protected function fixColumnBindings() {
+    $null = array();
+    $meta = $this->getColumnMetaCustom();
+    $this->columnNames = array_column($meta, 'name');
+    foreach ($meta as $i => $meta) {
+      $type = $meta['sqlsrv_type'];
+      switch($type) {
+        case 'varbinary':
+          $null[$i] = NULL;
+          $this->bindColumn($i + 1, $null[$i], PDO::PARAM_LOB, 0, PDO::SQLSRV_ENCODING_BINARY);
+          break;
+        case 'int':
+        case 'bit':
+        case 'smallint':
+        case 'tinyint':
+          $null[$i] = NULL;
+          $this->bindColumn($i + 1, $null[$i], PDO::PARAM_INT);
+          break;
+        case 'nvarchar':
+        case 'varchar':
+          $null[$i] = NULL;
+          $this->bindColumn($i + 1, $null[$i], PDO::PARAM_STR, 0, PDO::SQLSRV_ENCODING_UTF8);
+          break;
+      }
+    }
+  }
+
+  /**
+   * Summary of BindArguments
+   *
+   * @param PDOStatement $stmt
+   * @param array $values
+   */
+  public function BindArguments(array &$values) {
+    foreach ($values as $key => &$value) {
+      $this->bindParam($key, $value, PDO::PARAM_STR);
+    }
+  }
+
+  /**
+   * Summary of BindExpressions
+   *
+   * @param array $values
+   * @param array $remove_from
+   */
+  public function BindExpressions(array &$values, array &$remove_from) {
+    foreach ($values as $key => $value) {
+      unset($remove_from[$key]);
+      if (empty($value['arguments'])) {
+        continue;
+      }
+      if (is_array($value['arguments'])) {
+        foreach ($value['arguments'] as $placeholder => $argument) {
+          // We assume that an expression will never happen on a BLOB field,
+          // which is a fairly safe assumption to make since in most cases
+          // it would be an invalid query anyway.
+          $this->bindParam($placeholder, $value['arguments'][$placeholder]);
+        }
+      }
+      else {
+        $this->bindParam($key, $value['arguments'], PDO::PARAM_STR);
+      }
+    }
+  }
+
+  /**
+   * Binds a set of values to a PDO Statement,
+   * taking care of properly managing binary data.
+   *
+   * @param PDOStatement $stmt
+   *   PDOStatement to bind the values to
+   *
+   * @param array $values
+   *   Values to bind. It's an array where the keys are column
+   *   names and the values what is going to be inserted.
+   *
+   * @param array $blobs
+   *   When sending binary data to the PDO driver, we need to keep
+   *   track of the original references to data
+   *
+   * @param array $ref_prefix
+   *   The $ref_holder might be shared between statements, use this
+   *   prefix to prevent key colision.
+   *
+   * @param mixed $placeholder_prefix
+   *   Prefix to use for generating the query placeholders.
+   *
+   * @param mixed $max_placeholder
+   *   Placeholder count, if NULL will start with 0.
+   *
+   */
+  public function BindValues(array &$values, array &$blobs, $placeholder_prefix, $columnInformation, &$max_placeholder = NULL, $blob_suffix = NULL) {
+    if (empty($max_placeholder)) {
+      $max_placeholder = 0;
+    }
+    foreach ($values as $field_name => &$field_value) {
+      $placeholder = $placeholder_prefix . $max_placeholder++;
+      $blob_key = $placeholder . $blob_suffix;
+      if (isset($columnInformation['blobs'][$field_name])) {
+        $blobs[$blob_key] = fopen('php://memory', 'a');
+        fwrite($blobs[$blob_key], $field_value);
+        rewind($blobs[$blob_key]);
+        $this->bindParam($placeholder, $blobs[$blob_key], PDO::PARAM_LOB, 0, PDO::SQLSRV_ENCODING_BINARY);
+      }
+      else {
+        // Even though not a blob, make sure we retain a copy of these values.
+        $blobs[$blob_key] = $field_value;
+        $this->bindParam($placeholder, $blobs[$blob_key], PDO::PARAM_STR);
+      }
+    }
+  }
+
+  /**
+   * Execute a statement.
+   *
+   * @param array $args
+   */
+  public function execute($args = NULL) {
+    $this->query_signature = md5($this->queryString);
+    if ($this->cnn->InDoomedTransaction()) {
+      $this->cnn->ThrowDoomedTransactionException();
+    }
+    $result = NULL;
+    try {
+      $count = 0;
+      while (TRUE) {
+        try {
+          $count++;
+          $result = parent::execute($args);
+          break;
+        }
+        catch (\PDOException $e) {
+          // If the maximum retry limit is exceeded
+          // throw the exception.
+          if ($count > self::RETRY_MAX) {
+            throw $e;
+          }
+          $safe = FALSE;
+          if ($this->options[Connection::PDO_RETRYONINTEGRITYVIOLATION] === TRUE
+            && in_array((string) $e->getCode(), $this->INTEGRITY_VIOLATION_CONSTRAINT_CODES)) {
+            $safe = TRUE;
+          }
+          if ($this->options[Connection::PDO_RESILIENTRETRY] === TRUE
+            && in_array((string) $e->getCode(), $this->CONNECTION_FAILED_CODES)) {
+            $safe = TRUE;
+          }
+          if (!$safe) {
+            throw $e;
+          }
+          else {
+            usleep($count * (1000000 * self::RETRY_DELAY));
+          }
+        }
+      }
+      if ($result == FALSE) {
+        $this->cnn->ThrowPdoException($this, NULL);
+      }
+      return $result;
+    }
+    catch (\PDOException $e) {
+      $this->cnn->NotifyException($e);
+      $this->cnn->ThrowPdoException($this, $e);
+      return NULL;
+    }
+  }
+
+  /**
+   * Optimized for common use cases.
+   *
+   * @param int $key_index
+   * @param int $value_index
+   *
+   * @return array
+   */
+  public function fetchAllKeyed($key_index = 0, $value_index = 1) {
+    // If we are asked for the default behaviour, rely
+    // on the PDO as being faster. The result set needs to exactly bee 2 columns.
+    if ($key_index == 0 && $value_index == 1 && $this->columnCount() == 2) {
+      $this->setFetchMode(PDO::FETCH_KEY_PAIR);
+      return $this->fetchAll();
+    }
+    // We need to do this manually.
+    $return = array();
+    $this->setFetchMode(PDO::FETCH_NUM);
+    foreach ($this as $record) {
+      $return[$record[$key_index]] = $record[$value_index];
+    }
+    return $return;
+  }
+}
\ No newline at end of file
diff --git a/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Utils.php b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Utils.php
new file mode 100644
index 00000000..eb097934
--- /dev/null
+++ b/drivers/lib/Drupal/Driver/Database/sqlsrv/mssql/src/Utils.php
@@ -0,0 +1,199 @@
+<?php
+
+/* Copyright (C) 2015 CompuGlobalHyperMegacom - All Rights Reserved
+ * 
+ * You may use, distribute and modify this code under the
+ * terms of the license, which unfortunately won't be
+ * written for another century.
+ *
+ * You should have received a copy of the license with
+ * this file. If not, please write to compuglobalhypermegacom@gmail.com@gmail.com
+ */
+
+namespace mssql;
+use Symfony\Component\Yaml\Parser;
+use PDO as PDO;
+use PDOStatement as PDOStatement;
+class Utils {
+  /**
+   * Returns the spec for a MSSQL data type definition.
+   *
+   * @param string $type
+   *
+   * @return string
+   */
+  public static function GetMSSQLType($type) {
+    $matches = array();
+    if(preg_match('/^[a-zA-Z]*/' , $type, $matches)) {
+      return reset($matches);
+    }
+    return $type;
+  }
+  /**
+   * Get some info about extensions...
+   *
+   * @param \ReflectionExtension $re
+   *
+   * @return ExtensionData
+   */
+  public static function ExtensionData($name) {
+    $re = new \ReflectionExtension($name);
+    $data = new ExtensionData();
+    $data->Name($re->getName() ?: NULL);
+    $data->Version($re->getVersion() ?: NULL);
+    $data->ClassName(PHP_EOL.implode(", ",$re->getClassNames()) ?: NULL);
+    $constants = '';
+    foreach ($re->getConstants() as $key => $value) $constants .= "\n{$key}:={$value}";
+    $data->Constants($constants);
+    $data->Dependencies($re->getDependencies() ?: NULL);
+    $data->Functions(PHP_EOL.implode(", ",array_keys($re->getFunctions())) ?: NULL);
+    $data->IniEntries($re->getINIEntries() ?: NULL);
+    $data->Persistent($re->isPersistent() ?: NULL);
+    $data->Temporary($re->isTemporary() ?: NULL);
+    return $data;
+  }
+  /**
+   * Wether or not this is a Windows operating system.
+   */
+  public static function WindowsOS() {
+    return strncasecmp(PHP_OS, 'WIN', 3) == 0;
+  }
+  /**
+   * Deploy custom functions.
+   *
+   * @param \PDO $connection
+   *   Connection used for deployment.
+   *
+   * @param boolean $redeploy
+   *   Whether to redeploy existing functions, or only missing ones.
+   */
+  public static function DeployCustomFunctions(Connection $connection, $base_path, $redeploy = FALSE) {
+    $yaml = new Parser();
+    $configuration = $yaml->parse(file_get_contents("$base_path/configuration.yml"));
+    foreach ($configuration['functions'] as $function) {
+      $name = $function['name'];
+      $path = "$base_path/{$function['file']}";
+      $exists = $connection->Scheme()->functionExists($name);
+      if ($exists && !$redeploy) {
+        continue;
+      }
+      if ($exists) {
+        $connection->Scheme()->FunctionDrop($name);
+      }
+      $script = trim(static::removeUtf8Bom(file_get_contents($path)));
+      $connection->query_execute($script);
+    }
+  }
+  /**
+   * Remove Byte Order Mark from UTF8 string.
+   *
+   * @param string $text
+   * @return string
+   */
+  public static function removeUtf8Bom($text) {
+    $bom = pack('H*','EFBBBF');
+    $text = preg_replace("/^$bom/", '', $text);
+    return $text;
+  }
+  /**
+   * Gets the statement needed to convert one type to another
+   *
+   * @param string $reference
+   * @param string $source_type
+   * @param string $destination_type
+   * @param string $destination_collation
+   */
+  public static function convertTypes($reference, $source_type, $destination_type, $destination_collation = null) {
+    $field_old_expression = $reference;
+    // If the destination column is text, but source column is not text
+    // we need to do an explicit convert to text before collating.
+    if (static::IsTextType($destination_type) && !static::IsTextType($source_type)) {
+      $field_old_expression = "CONVERT($destination_type, $field_old_expression)";
+    }
+    // Add collation data if necessary.
+    if(!empty($destination_collation)) {
+      $field_old_expression .= " COLLATE $destination_collation";
+    }
+    $result = '';
+    if (static::GetMSSQLType($destination_type) == 'varbinary') {
+      switch (static::GetMSSQLType($source_type)) {
+        case 'varchar':
+        case 'char':
+          $result = "CAST($field_old_expression AS $destination_type)";
+          break;
+        case 'nvarchar':
+          $result = "CONVERT($destination_type, $field_old_expression)";
+          break;
+        default:
+          $result = "CONVERT($destination_type, $field_old_expression, 1)";
+      }
+    }
+    else {
+      $result = "CONVERT($destination_type, $field_old_expression)";
+    }
+    return $result;
+  }
+  /**
+   * If this data type contains text.
+   *
+   * @param string $type
+   */
+  public static function IsTextType($type) {
+    return in_array(static::GetMSSQLType($type), array('char', 'varchar', 'text', 'nchar', 'nvarchar', 'ntext'));
+  }
+  /**
+   * @param null|string $property_name
+   *
+   * @param null|string $level0_object_type
+   *
+   * @param null|string $level0_object_name
+   *
+   * @param null|string $level1_object_type
+   *
+   * @param null|string $level1_object_name
+   *
+   * @param null|string $level2_object_type
+   *
+   * @param null|string $level2_object_name
+   */
+  public static function GetExtendedProperty($property_name = NULL,
+                                             $level0_object_type = NULL,
+                                             $level0_object_name = NULL,
+                                             $level1_object_type = NULL,
+                                             $level1_object_name = NULL,
+                                             $level2_object_type = NULL,
+                                             $level2_object_name = NULL) {
+    $level_o = array("ASSEMBLY","CONTRACT","EVENT NOTIFICATION","FILEGROUP","MESSAGE TYPE","PARTITION FUNCTION","PARTITION SCHEME","REMOTE SERVICE BINDING","ROUTE","SCHEMA","SERVICE","TRIGGER","TYPE","USER","NULL");
+    if (!empty($level0_object_type) && !in_array(strtoupper($level0_object_type), $level_o)) {
+      throw new \Exception("Invalid Level0 Object Type.");
+    }
+    $level_1 = array("AGGREGATE","DEFAULT","FUNCTION","LOGICAL FILE NAME","PROCEDURE","QUEUE","RULE","SYNONYM","TABLE","TYPE","VIEW","XML","SCHEMA COLLECTION","NULL");
+    if (!empty($level1_object_type) && !in_array(strtoupper($level1_object_type), $level_1)) {
+      throw new \Exception("Invalid Level1 Object Type.");
+    }
+    $level_2 = array("COLUMN","CONSTRAINT","EVENT NOTIFICATION","INDEX","PARAMETER","TRIGGER","NULL");
+    if (!empty($level2_object_type) && !in_array(strtoupper($level2_object_type), $level_2)) {
+      throw new \Exception("Invalid Level2 Object Type.");
+    }
+    $query = <<<EVB
+  SELECT
+    CONVERT(nvarchar(max), value) AS value,
+    CONVERT(nvarchar(max), objtype) AS objtype,
+    CONVERT(nvarchar(max), objname) AS objname,
+    CONVERT(nvarchar(max), name) AS name
+  FROM fn_listextendedproperty(:property_name, :level0_object_type, :level0_object_name,:level1_object_type, :level1_object_name,:level2_object_type, :level2_object_name)
+EVB;
+    return array(
+      'query' => $query,
+        'args' => array(
+            ':property_name' => $property_name,
+            ':level0_object_type' => $level0_object_type,
+            ':level0_object_name' => $level0_object_name,
+            ':level1_object_type' => $level1_object_type,
+            ':level1_object_name' => $level1_object_name,
+            ':level2_object_type' => $level2_object_type,
+          ':level2_object_name' => $level2_object_name,
+        )
+    );
+  }
+}
\ No newline at end of file
diff --git a/sqlsrv.services.yml b/sqlsrv.services.yml
new file mode 100644
index 00000000..2125c948
--- /dev/null
+++ b/sqlsrv.services.yml
@@ -0,0 +1,8 @@
+services:
+  # Provide custom cache bin.
+  cache.sqlsrv:
+    class: Drupal\Core\Cache\CacheBackendInterface
+    tags:
+      - { name: cache.bin }
+    factory: cache_factory:get
+    arguments: [sqlsrv]
